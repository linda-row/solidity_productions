const { expect } = require("chai");

describe("Vulnerabilities", function () {
    it("Hiding Malicious Code with External Contract should not work", async function () {
        const Bar = await ethers.getContractFactory("Bar");
        const bar = await Bar.deploy();

        const Mal = await ethers.getContractFactory("Mal");
        const mal = await Mal.deploy();
        
        const Foo = await ethers.getContractFactory("Foo");
        const foo = await Foo.deploy(mal.getAddress());

        let result = await foo.callBar();
        expect(result).to.equal("Bar was called");
    });

    it("Bypass Is-Contract Check should not work", async function () {
        let signers = await ethers.getSigners();
        const { target, attack } = await targetAttackDeploy("SizeCheckContract", "SizeCheckAttack", signers[0], signers[0], ethers.parseEther("0"));

        let result = await target.pwned();
        let check = await attack.isContract();
        expect(result).to.equal(false);
        expect(check).to.equal(true);
    });

    it("Denial of Service should not work", async function () {
        let signers = await ethers.getSigners();
        const { target, attack } = await targetAttackDeploy("KingContract", "KingAttack", signers[0], signers[0], ethers.parseEther("0"));

        await attack.attack({ value: ethers.parseEther("0.1") });
        
        let value = ethers.parseEther("0.2");
        let errorOccurred = false;
        try {
            await target.claimThrone({ value: value });
        } catch (error) {
            errorOccurred = true;
            expect(error.message).to.not.include("Failed to send Ether");
        }
        expect(errorOccurred).to.equal(false);

        expect(target.balance()).to.equal(value);
        expect(target.king()).to.equal(signers[0].address);
    });

    it("Phishing with tx.origin should not work", async function () {
        let signers = await ethers.getSigners();
        const { target, attack } = await targetAttackDeploy("OriginContract", "OriginAttack", signers[0], signers[1], ethers.parseEther("0.2"));

        const balanceBefore = await ethers.provider.getBalance(target.getAddress());
        let errorOccurred = false;
        try {
            await attack.connect(signers[0]).attack();
        } catch (error) {
            errorOccurred = true;
            expect(error.message).to.include("Not owner");
        }
        expect(errorOccurred).to.equal(true);

        const balanceAfter = await ethers.provider.getBalance(target.getAddress());
        expect(balanceBefore - balanceAfter).to.equal(0);
    });

    it("Re-Entrancy should not work", async function () {
        let signers = await ethers.getSigners();
        const { target, attack } = await targetAttackDeploy("ReEntrancyContract", "ReEntrancyAttack", signers[0], signers[1], ethers.parseEther("0"));

        await target.connect(signers[0]).deposit({ value: ethers.parseEther("8")});

        const targetBalanceBefore = await target.getContractBalance();
        const attackBalanceBefore = await attack.getContractBalance();
        let errorOccurred = false;
        try {
            await attack.connect(signers[1]).attack({ value: ethers.parseEther("1")});
        } catch (error) {
            errorOccurred = true;
            expect(error.message).to.include("Insufficient balance");
        }
        expect(errorOccurred).to.equal(true);

        const targetBalanceAfter = await target.getContractBalance();
        const attackBalanceAfter = await attack.getContractBalance();
        expect(targetBalanceBefore - targetBalanceAfter).to.equal(0);
        expect(attackBalanceAfter - attackBalanceBefore).to.equal(0);
    });

    it("Selfdestruct-attack should not work", async function () {
        let signers = await ethers.getSigners();
        const { target, attack } = await targetAttackDeploy("SelfdestructContract", "SelfdestructAttack", signers[0], signers[1], ethers.parseEther("0"));

        await attack.connect(signers[1]).attack({ value: ethers.parseEther("8")});

        let errorOccurred = false;
        try {
            await target.connect(signers[0]).deposit({ value: ethers.parseEther("1")});
        } catch (error) {
            errorOccurred = true;
            expect(error.message).to.not.include("Game is over");
        }
        expect(errorOccurred).to.equal(false);
    });
});

async function targetAttackDeploy(targetContract, attackContract, targetSigner, attackSigner, targetAmount) {
    const Target = await ethers.getContractFactory(targetContract);
    const target = await Target.connect(targetSigner).deploy({ value: targetAmount});

    const Attack = await ethers.getContractFactory(attackContract);
    const attack = await Attack.connect(attackSigner).deploy(target.getAddress());

    return {target, attack};
}